// Code generated by MockGen. DO NOT EDIT.
// Source: k8s_manager_interface.go
//
// Generated by this command:
//
//	mockgen -destination=mocks/mock_k8s_manager.go -package=mocks -source=k8s_manager_interface.go K8SManager
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	k8s "github.com/stacklok/toolhive/pkg/workloads/k8s"
	gomock "go.uber.org/mock/gomock"
)

// MockK8SManager is a mock of K8SManager interface.
type MockK8SManager struct {
	ctrl     *gomock.Controller
	recorder *MockK8SManagerMockRecorder
	isgomock struct{}
}

// MockK8SManagerMockRecorder is the mock recorder for MockK8SManager.
type MockK8SManagerMockRecorder struct {
	mock *MockK8SManager
}

// NewMockK8SManager creates a new mock instance.
func NewMockK8SManager(ctrl *gomock.Controller) *MockK8SManager {
	mock := &MockK8SManager{ctrl: ctrl}
	mock.recorder = &MockK8SManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockK8SManager) EXPECT() *MockK8SManagerMockRecorder {
	return m.recorder
}

// DoesWorkloadExist mocks base method.
func (m *MockK8SManager) DoesWorkloadExist(ctx context.Context, workloadName string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoesWorkloadExist", ctx, workloadName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoesWorkloadExist indicates an expected call of DoesWorkloadExist.
func (mr *MockK8SManagerMockRecorder) DoesWorkloadExist(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoesWorkloadExist", reflect.TypeOf((*MockK8SManager)(nil).DoesWorkloadExist), ctx, workloadName)
}

// GetLogs mocks base method.
func (m *MockK8SManager) GetLogs(ctx context.Context, containerName string, follow bool) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogs", ctx, containerName, follow)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLogs indicates an expected call of GetLogs.
func (mr *MockK8SManagerMockRecorder) GetLogs(ctx, containerName, follow any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogs", reflect.TypeOf((*MockK8SManager)(nil).GetLogs), ctx, containerName, follow)
}

// GetProxyLogs mocks base method.
func (m *MockK8SManager) GetProxyLogs(ctx context.Context, workloadName string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetProxyLogs", ctx, workloadName)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetProxyLogs indicates an expected call of GetProxyLogs.
func (mr *MockK8SManagerMockRecorder) GetProxyLogs(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProxyLogs", reflect.TypeOf((*MockK8SManager)(nil).GetProxyLogs), ctx, workloadName)
}

// GetWorkload mocks base method.
func (m *MockK8SManager) GetWorkload(ctx context.Context, workloadName string) (k8s.Workload, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkload", ctx, workloadName)
	ret0, _ := ret[0].(k8s.Workload)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkload indicates an expected call of GetWorkload.
func (mr *MockK8SManagerMockRecorder) GetWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkload", reflect.TypeOf((*MockK8SManager)(nil).GetWorkload), ctx, workloadName)
}

// ListWorkloads mocks base method.
func (m *MockK8SManager) ListWorkloads(ctx context.Context, listAll bool, labelFilters ...string) ([]k8s.Workload, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, listAll}
	for _, a := range labelFilters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkloads", varargs...)
	ret0, _ := ret[0].([]k8s.Workload)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkloads indicates an expected call of ListWorkloads.
func (mr *MockK8SManagerMockRecorder) ListWorkloads(ctx, listAll any, labelFilters ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, listAll}, labelFilters...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkloads", reflect.TypeOf((*MockK8SManager)(nil).ListWorkloads), varargs...)
}

// ListWorkloadsInGroup mocks base method.
func (m *MockK8SManager) ListWorkloadsInGroup(ctx context.Context, groupName string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListWorkloadsInGroup", ctx, groupName)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkloadsInGroup indicates an expected call of ListWorkloadsInGroup.
func (mr *MockK8SManagerMockRecorder) ListWorkloadsInGroup(ctx, groupName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkloadsInGroup", reflect.TypeOf((*MockK8SManager)(nil).ListWorkloadsInGroup), ctx, groupName)
}

// MoveToGroup mocks base method.
func (m *MockK8SManager) MoveToGroup(ctx context.Context, workloadNames []string, groupFrom, groupTo string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MoveToGroup", ctx, workloadNames, groupFrom, groupTo)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveToGroup indicates an expected call of MoveToGroup.
func (mr *MockK8SManagerMockRecorder) MoveToGroup(ctx, workloadNames, groupFrom, groupTo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveToGroup", reflect.TypeOf((*MockK8SManager)(nil).MoveToGroup), ctx, workloadNames, groupFrom, groupTo)
}
