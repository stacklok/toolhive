// Code generated by MockGen. DO NOT EDIT.
// Source: manager.go
//
// Generated by this command:
//
//	mockgen -destination=mocks/mock_manager.go -package=mocks -source=manager.go Manager
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	core "github.com/stacklok/toolhive/pkg/core"
	runner "github.com/stacklok/toolhive/pkg/runner"
	gomock "go.uber.org/mock/gomock"
	errgroup "golang.org/x/sync/errgroup"
)

// MockManager is a mock of Manager interface.
type MockManager struct {
	ctrl     *gomock.Controller
	recorder *MockManagerMockRecorder
	isgomock struct{}
}

// MockManagerMockRecorder is the mock recorder for MockManager.
type MockManagerMockRecorder struct {
	mock *MockManager
}

// NewMockManager creates a new mock instance.
func NewMockManager(ctrl *gomock.Controller) *MockManager {
	mock := &MockManager{ctrl: ctrl}
	mock.recorder = &MockManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockManager) EXPECT() *MockManagerMockRecorder {
	return m.recorder
}

// DeleteWorkloads mocks base method.
func (m *MockManager) DeleteWorkloads(ctx context.Context, names []string) (*errgroup.Group, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteWorkloads", ctx, names)
	ret0, _ := ret[0].(*errgroup.Group)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWorkloads indicates an expected call of DeleteWorkloads.
func (mr *MockManagerMockRecorder) DeleteWorkloads(ctx, names any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkloads", reflect.TypeOf((*MockManager)(nil).DeleteWorkloads), ctx, names)
}

// DoesWorkloadExist mocks base method.
func (m *MockManager) DoesWorkloadExist(ctx context.Context, workloadName string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoesWorkloadExist", ctx, workloadName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoesWorkloadExist indicates an expected call of DoesWorkloadExist.
func (mr *MockManagerMockRecorder) DoesWorkloadExist(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoesWorkloadExist", reflect.TypeOf((*MockManager)(nil).DoesWorkloadExist), ctx, workloadName)
}

// GetLogs mocks base method.
func (m *MockManager) GetLogs(ctx context.Context, containerName string, follow bool) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogs", ctx, containerName, follow)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLogs indicates an expected call of GetLogs.
func (mr *MockManagerMockRecorder) GetLogs(ctx, containerName, follow any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogs", reflect.TypeOf((*MockManager)(nil).GetLogs), ctx, containerName, follow)
}

// GetProxyLogs mocks base method.
func (m *MockManager) GetProxyLogs(ctx context.Context, workloadName string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetProxyLogs", ctx, workloadName)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetProxyLogs indicates an expected call of GetProxyLogs.
func (mr *MockManagerMockRecorder) GetProxyLogs(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProxyLogs", reflect.TypeOf((*MockManager)(nil).GetProxyLogs), ctx, workloadName)
}

// GetWorkload mocks base method.
func (m *MockManager) GetWorkload(ctx context.Context, workloadName string) (core.Workload, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkload", ctx, workloadName)
	ret0, _ := ret[0].(core.Workload)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkload indicates an expected call of GetWorkload.
func (mr *MockManagerMockRecorder) GetWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkload", reflect.TypeOf((*MockManager)(nil).GetWorkload), ctx, workloadName)
}

// ListWorkloads mocks base method.
func (m *MockManager) ListWorkloads(ctx context.Context, listAll bool, labelFilters ...string) ([]core.Workload, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, listAll}
	for _, a := range labelFilters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkloads", varargs...)
	ret0, _ := ret[0].([]core.Workload)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkloads indicates an expected call of ListWorkloads.
func (mr *MockManagerMockRecorder) ListWorkloads(ctx, listAll any, labelFilters ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, listAll}, labelFilters...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkloads", reflect.TypeOf((*MockManager)(nil).ListWorkloads), varargs...)
}

// ListWorkloadsInGroup mocks base method.
func (m *MockManager) ListWorkloadsInGroup(ctx context.Context, groupName string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListWorkloadsInGroup", ctx, groupName)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkloadsInGroup indicates an expected call of ListWorkloadsInGroup.
func (mr *MockManagerMockRecorder) ListWorkloadsInGroup(ctx, groupName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkloadsInGroup", reflect.TypeOf((*MockManager)(nil).ListWorkloadsInGroup), ctx, groupName)
}

// MoveToGroup mocks base method.
func (m *MockManager) MoveToGroup(ctx context.Context, workloadNames []string, groupFrom, groupTo string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MoveToGroup", ctx, workloadNames, groupFrom, groupTo)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveToGroup indicates an expected call of MoveToGroup.
func (mr *MockManagerMockRecorder) MoveToGroup(ctx, workloadNames, groupFrom, groupTo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveToGroup", reflect.TypeOf((*MockManager)(nil).MoveToGroup), ctx, workloadNames, groupFrom, groupTo)
}

// RestartWorkloads mocks base method.
func (m *MockManager) RestartWorkloads(ctx context.Context, names []string, foreground bool) (*errgroup.Group, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestartWorkloads", ctx, names, foreground)
	ret0, _ := ret[0].(*errgroup.Group)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RestartWorkloads indicates an expected call of RestartWorkloads.
func (mr *MockManagerMockRecorder) RestartWorkloads(ctx, names, foreground any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestartWorkloads", reflect.TypeOf((*MockManager)(nil).RestartWorkloads), ctx, names, foreground)
}

// RunWorkload mocks base method.
func (m *MockManager) RunWorkload(ctx context.Context, runConfig *runner.RunConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWorkload", ctx, runConfig)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWorkload indicates an expected call of RunWorkload.
func (mr *MockManagerMockRecorder) RunWorkload(ctx, runConfig any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWorkload", reflect.TypeOf((*MockManager)(nil).RunWorkload), ctx, runConfig)
}

// RunWorkloadDetached mocks base method.
func (m *MockManager) RunWorkloadDetached(ctx context.Context, runConfig *runner.RunConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWorkloadDetached", ctx, runConfig)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWorkloadDetached indicates an expected call of RunWorkloadDetached.
func (mr *MockManagerMockRecorder) RunWorkloadDetached(ctx, runConfig any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWorkloadDetached", reflect.TypeOf((*MockManager)(nil).RunWorkloadDetached), ctx, runConfig)
}

// StopWorkloads mocks base method.
func (m *MockManager) StopWorkloads(ctx context.Context, names []string) (*errgroup.Group, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StopWorkloads", ctx, names)
	ret0, _ := ret[0].(*errgroup.Group)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StopWorkloads indicates an expected call of StopWorkloads.
func (mr *MockManagerMockRecorder) StopWorkloads(ctx, names any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopWorkloads", reflect.TypeOf((*MockManager)(nil).StopWorkloads), ctx, names)
}

// UpdateWorkload mocks base method.
func (m *MockManager) UpdateWorkload(ctx context.Context, workloadName string, newConfig *runner.RunConfig) (*errgroup.Group, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWorkload", ctx, workloadName, newConfig)
	ret0, _ := ret[0].(*errgroup.Group)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWorkload indicates an expected call of UpdateWorkload.
func (mr *MockManagerMockRecorder) UpdateWorkload(ctx, workloadName, newConfig any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkload", reflect.TypeOf((*MockManager)(nil).UpdateWorkload), ctx, workloadName, newConfig)
}
