apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: sse-mcp-server
spec:
  description: Deploys SSE MCP server and verifies it's running
  timeouts:
    apply: 30s
    assert: 60s
    cleanup: 30s
    exec: 300s
  steps:
  - name: verify-operator
    description: Ensure operator is ready before testing
    try:
    - assert:
        file: ../../setup/assert-operator-ready.yaml
    - assert:
        file: ../../setup/namespace.yaml
      
  - name: deploy-mcpserver
    description: Deploy a basic MCPServer instance and verify it's ready
    try:
    - apply:
        file: mcpserver.yaml
    - assert:
        file: mcpserver.yaml
    - assert:
        file: assert-mcpserver-running.yaml
    - assert:
        file: assert-mcpserver-pod-running.yaml
    - assert:
        file: assert-mcpserver-headless-svc.yaml
    - assert:
        file: assert-mcpserver-proxy-runner-running.yaml
    - assert:
        file: assert-mcpserver-proxy-runner-svc.yaml
    - assert:
        file: ../common/proxyrunner-role.yaml
    - assert:
        file: ../common/proxyrunner-rolebinding.yaml
    - assert:
        file: ../common/proxyrunner-serviceaccount.yaml
    # Validate that ConfigMap is created with runconfig.json content (multi-tenancy)
    - script:
        content: |
          echo "Verifying ConfigMap creation and content in test-namespace..."
          
          # Wait for ConfigMap to be created
          for i in $(seq 1 10); do
            if kubectl get configmap yardstick-runconfig -n test-namespace >/dev/null 2>&1; then
              echo "âœ“ ConfigMap yardstick-runconfig exists in test-namespace"
              break
            fi
            echo "  Waiting for ConfigMap... (attempt $i/10)"
            sleep 2
          done
          
          # Verify ConfigMap contains runconfig.json with proper content
          CONFIGMAP_JSON=$(kubectl get configmap yardstick-runconfig -n test-namespace -o jsonpath='{.data.runconfig\.json}' 2>/dev/null || echo "")
          
          if [ -z "$CONFIGMAP_JSON" ]; then
            echo "âœ— ConfigMap does not contain runconfig.json data"
            kubectl get configmap yardstick-runconfig -n test-namespace -o yaml
            exit 1
          fi
          
          echo "âœ“ ConfigMap contains runconfig.json data"
          
          # Validate JSON structure contains expected fields
          if echo "$CONFIGMAP_JSON" | jq -e '.schema_version and .image and .name and .transport' > /dev/null 2>&1; then
            echo "âœ“ runconfig.json contains required fields (schema_version, image, name, transport)"
          else
            echo "âœ— runconfig.json missing required fields"
            echo "ConfigMap content:"
            echo "$CONFIGMAP_JSON"
            exit 1
          fi
          
          # Verify transport matches expected value (sse)
          TRANSPORT=$(echo "$CONFIGMAP_JSON" | jq -r '.transport' 2>/dev/null)
          if [ "$TRANSPORT" = "sse" ]; then
            echo "âœ“ runconfig.json transport is correctly set to 'sse'"
          else
            echo "âœ— runconfig.json transport is '$TRANSPORT', expected 'sse'"
            exit 1
          fi
          
          echo "âœ… ConfigMap validation passed in multi-tenancy mode!"
    - apply:
        file: ../common/proxy-svc-loadbalancer.yaml
    - assert:
        file: ../common/assert-proxy-svc-loadbalancer-ip.yaml

  - name: test-mcp-server
    description: Test the SSE->SSE MCP server by sending requests at the toolhive proxy
    try:
    - script:
        content: |
          # Get LoadBalancer external IP
          echo "Getting LoadBalancer external IP for service mcp-yardstick-proxy-lb..."
          EXTERNAL_IP=$(kubectl get svc mcp-yardstick-proxy-lb -n test-namespace -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo "LoadBalancer did not get external IP within timeout"
            kubectl describe svc mcp-yardstick-proxy-lb -n test-namespace
            exit 1
          fi
          
          # Wait additional time for LoadBalancer to be ready
          echo "Waiting for LoadBalancer to be ready..."
          
          # Function to retry yardstick-client commands with backoff
          retry_yardstick() {
            local max_attempts=5
            local delay=2
            local attempt=1
            local cmd="$@"
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval $cmd; then
                echo "âœ“ Command succeeded on attempt $attempt"
                return 0
              else
                echo "! Command failed on attempt $attempt"
                if [ $attempt -lt $max_attempts ]; then
                  echo "Waiting ${delay}s before retry..."
                  sleep $delay
                  delay=$((delay * 2))  # exponential backoff
                fi
              fi
              attempt=$((attempt + 1))
            done
            
            echo "! Command failed after $max_attempts attempts"
            return 1
          }
          
          echo "ğŸŒŠ ========== SSE->SSE TRANSPORT TESTING =========="
          echo "ğŸ“¡ Testing SSE transport on port 8080..."
          
          # Test SSE endpoint with client binary
          echo "ğŸŒŠ Testing SSE endpoint with client binary..."
          if retry_yardstick "yardstick-client -transport sse -address $EXTERNAL_IP -port 8080 -action info"; then
              echo "âœ“ SSE client connection successful"
          else
              echo "! SSE client connection failed"
              exit 1
          fi
          
          # Longer delay between calls for CI stability
          
          # Test listing tools via SSE
          echo "ğŸ“‹ Testing tool listing via SSE..."
          if retry_yardstick "yardstick-client -transport sse -address $EXTERNAL_IP -port 8080 -action list-tools"; then
              echo "âœ“ SSE tools listing successful"
          else
              echo "! SSE tools listing failed"
              exit 1
          fi
          
          # Longer delay between calls for CI stability
          
          echo "ğŸ”§ Testing tool calling via SSE..."
          # We want to generate a random string to test the tool calling
          # and then check if the output contains the string
          TEST_INPUT_OUTPUT=$(openssl rand -hex 16)
          if retry_yardstick "timeout 30 yardstick-client -transport sse -address $EXTERNAL_IP -port 8080 -action=call-tool -tool=echo -args='{\"input\":\"$TEST_INPUT_OUTPUT\"}' | grep -q '$TEST_INPUT_OUTPUT'"; then
              echo "âœ“ SSE tool call returned expected output: $TEST_INPUT_OUTPUT"
          else
              echo "! SSE tool call failed or timed out"
              exit 1
          fi
          
          echo "âœ… All SSE->SSE transport tests passed!"
          exit 0
