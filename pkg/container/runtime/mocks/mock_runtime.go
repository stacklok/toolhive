// Code generated by MockGen. DO NOT EDIT.
// Source: types.go
//
// Generated by this command:
//
//	mockgen -destination=mocks/mock_runtime.go -package=mocks -source=types.go Runtime
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	io "io"
	reflect "reflect"

	runtime "github.com/stacklok/toolhive/pkg/container/runtime"
	permissions "github.com/stacklok/toolhive/pkg/permissions"
	gomock "go.uber.org/mock/gomock"
)

// MockDeployer is a mock of Deployer interface.
type MockDeployer struct {
	ctrl     *gomock.Controller
	recorder *MockDeployerMockRecorder
	isgomock struct{}
}

// MockDeployerMockRecorder is the mock recorder for MockDeployer.
type MockDeployerMockRecorder struct {
	mock *MockDeployer
}

// NewMockDeployer creates a new mock instance.
func NewMockDeployer(ctrl *gomock.Controller) *MockDeployer {
	mock := &MockDeployer{ctrl: ctrl}
	mock.recorder = &MockDeployerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployer) EXPECT() *MockDeployerMockRecorder {
	return m.recorder
}

// AttachToWorkload mocks base method.
func (m *MockDeployer) AttachToWorkload(ctx context.Context, workloadName string) (io.WriteCloser, io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AttachToWorkload", ctx, workloadName)
	ret0, _ := ret[0].(io.WriteCloser)
	ret1, _ := ret[1].(io.ReadCloser)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AttachToWorkload indicates an expected call of AttachToWorkload.
func (mr *MockDeployerMockRecorder) AttachToWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachToWorkload", reflect.TypeOf((*MockDeployer)(nil).AttachToWorkload), ctx, workloadName)
}

// DeployWorkload mocks base method.
func (m *MockDeployer) DeployWorkload(ctx context.Context, image, name string, command []string, envVars, labels map[string]string, permissionProfile *permissions.Profile, transportType string, options *runtime.DeployWorkloadOptions, isolateNetwork bool) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeployWorkload", ctx, image, name, command, envVars, labels, permissionProfile, transportType, options, isolateNetwork)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeployWorkload indicates an expected call of DeployWorkload.
func (mr *MockDeployerMockRecorder) DeployWorkload(ctx, image, name, command, envVars, labels, permissionProfile, transportType, options, isolateNetwork any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeployWorkload", reflect.TypeOf((*MockDeployer)(nil).DeployWorkload), ctx, image, name, command, envVars, labels, permissionProfile, transportType, options, isolateNetwork)
}

// IsWorkloadRunning mocks base method.
func (m *MockDeployer) IsWorkloadRunning(ctx context.Context, workloadName string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsWorkloadRunning", ctx, workloadName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsWorkloadRunning indicates an expected call of IsWorkloadRunning.
func (mr *MockDeployerMockRecorder) IsWorkloadRunning(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsWorkloadRunning", reflect.TypeOf((*MockDeployer)(nil).IsWorkloadRunning), ctx, workloadName)
}

// StopWorkload mocks base method.
func (m *MockDeployer) StopWorkload(ctx context.Context, workloadName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StopWorkload", ctx, workloadName)
	ret0, _ := ret[0].(error)
	return ret0
}

// StopWorkload indicates an expected call of StopWorkload.
func (mr *MockDeployerMockRecorder) StopWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopWorkload", reflect.TypeOf((*MockDeployer)(nil).StopWorkload), ctx, workloadName)
}

// MockRuntime is a mock of Runtime interface.
type MockRuntime struct {
	ctrl     *gomock.Controller
	recorder *MockRuntimeMockRecorder
	isgomock struct{}
}

// MockRuntimeMockRecorder is the mock recorder for MockRuntime.
type MockRuntimeMockRecorder struct {
	mock *MockRuntime
}

// NewMockRuntime creates a new mock instance.
func NewMockRuntime(ctrl *gomock.Controller) *MockRuntime {
	mock := &MockRuntime{ctrl: ctrl}
	mock.recorder = &MockRuntimeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuntime) EXPECT() *MockRuntimeMockRecorder {
	return m.recorder
}

// AttachToWorkload mocks base method.
func (m *MockRuntime) AttachToWorkload(ctx context.Context, workloadName string) (io.WriteCloser, io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AttachToWorkload", ctx, workloadName)
	ret0, _ := ret[0].(io.WriteCloser)
	ret1, _ := ret[1].(io.ReadCloser)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AttachToWorkload indicates an expected call of AttachToWorkload.
func (mr *MockRuntimeMockRecorder) AttachToWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachToWorkload", reflect.TypeOf((*MockRuntime)(nil).AttachToWorkload), ctx, workloadName)
}

// DeployWorkload mocks base method.
func (m *MockRuntime) DeployWorkload(ctx context.Context, image, name string, command []string, envVars, labels map[string]string, permissionProfile *permissions.Profile, transportType string, options *runtime.DeployWorkloadOptions, isolateNetwork bool) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeployWorkload", ctx, image, name, command, envVars, labels, permissionProfile, transportType, options, isolateNetwork)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeployWorkload indicates an expected call of DeployWorkload.
func (mr *MockRuntimeMockRecorder) DeployWorkload(ctx, image, name, command, envVars, labels, permissionProfile, transportType, options, isolateNetwork any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeployWorkload", reflect.TypeOf((*MockRuntime)(nil).DeployWorkload), ctx, image, name, command, envVars, labels, permissionProfile, transportType, options, isolateNetwork)
}

// GetWorkloadInfo mocks base method.
func (m *MockRuntime) GetWorkloadInfo(ctx context.Context, workloadName string) (runtime.ContainerInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkloadInfo", ctx, workloadName)
	ret0, _ := ret[0].(runtime.ContainerInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkloadInfo indicates an expected call of GetWorkloadInfo.
func (mr *MockRuntimeMockRecorder) GetWorkloadInfo(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkloadInfo", reflect.TypeOf((*MockRuntime)(nil).GetWorkloadInfo), ctx, workloadName)
}

// GetWorkloadLogs mocks base method.
func (m *MockRuntime) GetWorkloadLogs(ctx context.Context, workloadName string, follow bool) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkloadLogs", ctx, workloadName, follow)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkloadLogs indicates an expected call of GetWorkloadLogs.
func (mr *MockRuntimeMockRecorder) GetWorkloadLogs(ctx, workloadName, follow any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkloadLogs", reflect.TypeOf((*MockRuntime)(nil).GetWorkloadLogs), ctx, workloadName, follow)
}

// IsRunning mocks base method.
func (m *MockRuntime) IsRunning(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRunning", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// IsRunning indicates an expected call of IsRunning.
func (mr *MockRuntimeMockRecorder) IsRunning(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRunning", reflect.TypeOf((*MockRuntime)(nil).IsRunning), ctx)
}

// IsWorkloadRunning mocks base method.
func (m *MockRuntime) IsWorkloadRunning(ctx context.Context, workloadName string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsWorkloadRunning", ctx, workloadName)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsWorkloadRunning indicates an expected call of IsWorkloadRunning.
func (mr *MockRuntimeMockRecorder) IsWorkloadRunning(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsWorkloadRunning", reflect.TypeOf((*MockRuntime)(nil).IsWorkloadRunning), ctx, workloadName)
}

// ListWorkloads mocks base method.
func (m *MockRuntime) ListWorkloads(ctx context.Context) ([]runtime.ContainerInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListWorkloads", ctx)
	ret0, _ := ret[0].([]runtime.ContainerInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkloads indicates an expected call of ListWorkloads.
func (mr *MockRuntimeMockRecorder) ListWorkloads(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkloads", reflect.TypeOf((*MockRuntime)(nil).ListWorkloads), ctx)
}

// RemoveWorkload mocks base method.
func (m *MockRuntime) RemoveWorkload(ctx context.Context, workloadName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWorkload", ctx, workloadName)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWorkload indicates an expected call of RemoveWorkload.
func (mr *MockRuntimeMockRecorder) RemoveWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWorkload", reflect.TypeOf((*MockRuntime)(nil).RemoveWorkload), ctx, workloadName)
}

// StopWorkload mocks base method.
func (m *MockRuntime) StopWorkload(ctx context.Context, workloadName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StopWorkload", ctx, workloadName)
	ret0, _ := ret[0].(error)
	return ret0
}

// StopWorkload indicates an expected call of StopWorkload.
func (mr *MockRuntimeMockRecorder) StopWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopWorkload", reflect.TypeOf((*MockRuntime)(nil).StopWorkload), ctx, workloadName)
}

// MockMonitor is a mock of Monitor interface.
type MockMonitor struct {
	ctrl     *gomock.Controller
	recorder *MockMonitorMockRecorder
	isgomock struct{}
}

// MockMonitorMockRecorder is the mock recorder for MockMonitor.
type MockMonitorMockRecorder struct {
	mock *MockMonitor
}

// NewMockMonitor creates a new mock instance.
func NewMockMonitor(ctrl *gomock.Controller) *MockMonitor {
	mock := &MockMonitor{ctrl: ctrl}
	mock.recorder = &MockMonitorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMonitor) EXPECT() *MockMonitorMockRecorder {
	return m.recorder
}

// StartMonitoring mocks base method.
func (m *MockMonitor) StartMonitoring(ctx context.Context) (<-chan error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartMonitoring", ctx)
	ret0, _ := ret[0].(<-chan error)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartMonitoring indicates an expected call of StartMonitoring.
func (mr *MockMonitorMockRecorder) StartMonitoring(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartMonitoring", reflect.TypeOf((*MockMonitor)(nil).StartMonitoring), ctx)
}

// StopMonitoring mocks base method.
func (m *MockMonitor) StopMonitoring() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StopMonitoring")
}

// StopMonitoring indicates an expected call of StopMonitoring.
func (mr *MockMonitorMockRecorder) StopMonitoring() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopMonitoring", reflect.TypeOf((*MockMonitor)(nil).StopMonitoring))
}
