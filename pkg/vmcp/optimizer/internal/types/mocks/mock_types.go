// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/stacklok/toolhive/pkg/vmcp/optimizer/internal/types (interfaces: ToolStore,EmbeddingClient)
//
// Generated by this command:
//
//	mockgen -destination=mocks/mock_types.go -package=mocks github.com/stacklok/toolhive/pkg/vmcp/optimizer/internal/types ToolStore,EmbeddingClient
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	server "github.com/mark3labs/mcp-go/server"
	types "github.com/stacklok/toolhive/pkg/vmcp/optimizer/internal/types"
	gomock "go.uber.org/mock/gomock"
)

// MockToolStore is a mock of ToolStore interface.
type MockToolStore struct {
	ctrl     *gomock.Controller
	recorder *MockToolStoreMockRecorder
	isgomock struct{}
}

// MockToolStoreMockRecorder is the mock recorder for MockToolStore.
type MockToolStoreMockRecorder struct {
	mock *MockToolStore
}

// NewMockToolStore creates a new mock instance.
func NewMockToolStore(ctrl *gomock.Controller) *MockToolStore {
	mock := &MockToolStore{ctrl: ctrl}
	mock.recorder = &MockToolStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToolStore) EXPECT() *MockToolStoreMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockToolStore) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockToolStoreMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockToolStore)(nil).Close))
}

// Search mocks base method.
func (m *MockToolStore) Search(ctx context.Context, query string, allowedTools []string) ([]types.ToolMatch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Search", ctx, query, allowedTools)
	ret0, _ := ret[0].([]types.ToolMatch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Search indicates an expected call of Search.
func (mr *MockToolStoreMockRecorder) Search(ctx, query, allowedTools any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockToolStore)(nil).Search), ctx, query, allowedTools)
}

// UpsertTools mocks base method.
func (m *MockToolStore) UpsertTools(ctx context.Context, tools []server.ServerTool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTools", ctx, tools)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertTools indicates an expected call of UpsertTools.
func (mr *MockToolStoreMockRecorder) UpsertTools(ctx, tools any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTools", reflect.TypeOf((*MockToolStore)(nil).UpsertTools), ctx, tools)
}

// MockEmbeddingClient is a mock of EmbeddingClient interface.
type MockEmbeddingClient struct {
	ctrl     *gomock.Controller
	recorder *MockEmbeddingClientMockRecorder
	isgomock struct{}
}

// MockEmbeddingClientMockRecorder is the mock recorder for MockEmbeddingClient.
type MockEmbeddingClientMockRecorder struct {
	mock *MockEmbeddingClient
}

// NewMockEmbeddingClient creates a new mock instance.
func NewMockEmbeddingClient(ctrl *gomock.Controller) *MockEmbeddingClient {
	mock := &MockEmbeddingClient{ctrl: ctrl}
	mock.recorder = &MockEmbeddingClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEmbeddingClient) EXPECT() *MockEmbeddingClientMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockEmbeddingClient) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEmbeddingClientMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEmbeddingClient)(nil).Close))
}

// Embed mocks base method.
func (m *MockEmbeddingClient) Embed(ctx context.Context, text string) ([]float32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Embed", ctx, text)
	ret0, _ := ret[0].([]float32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Embed indicates an expected call of Embed.
func (mr *MockEmbeddingClientMockRecorder) Embed(ctx, text any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Embed", reflect.TypeOf((*MockEmbeddingClient)(nil).Embed), ctx, text)
}

// EmbedBatch mocks base method.
func (m *MockEmbeddingClient) EmbedBatch(ctx context.Context, texts []string) ([][]float32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EmbedBatch", ctx, texts)
	ret0, _ := ret[0].([][]float32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EmbedBatch indicates an expected call of EmbedBatch.
func (mr *MockEmbeddingClientMockRecorder) EmbedBatch(ctx, texts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EmbedBatch", reflect.TypeOf((*MockEmbeddingClient)(nil).EmbedBatch), ctx, texts)
}
