name: E2E Tests Lifecycle

on:
  workflow_dispatch:
  pull_request:
    paths:
      - 'cmd/vmcp/**'
      - 'cmd/thv-operator/**'
      - 'pkg/**'
      - 'test/e2e/thv-operator/**'
      - '.github/workflows/test-e2e-lifecycle.yml'

permissions:
  contents: read

jobs:
  e2e-test-lifecycle:
    name: E2E Test Lifecycle
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      YARDSTICK_IMAGE: ghcr.io/stackloklabs/yardstick/yardstick-server:1.1.1
    defaults:
      run:
        shell: bash
    strategy:
      fail-fast: false
      matrix:
        version: [
          "kindest/node:v1.33.7",
          "kindest/node:v1.34.3",
          "kindest/node:v1.35.0"
        ]

    steps:
    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

    - name: Set up Helm
      uses: azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 # v4.3.1

    - name: Setup Ko
      uses: ko-build/setup-ko@d006021bd0c28d1ce33a07e7943d48b079944c8d # v0.9

    - name: Set up Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
      with:
        go-version-file: 'go.mod'
        cache: true

    - name: Install Task
      uses: arduino/setup-task@v2
      with:
        version: 3.44.1
        repo-token: ${{ secrets.GITHUB_TOKEN }}

    - name: Create KIND Cluster with port mappings
      uses: helm/kind-action@ef37e7f390d99f746eb8b610417061a60e82a6cc # pin@v1.12.0
      with:
        cluster_name: toolhive
        version: v0.29.0
        config: test/e2e/thv-operator/kind-config.yaml
        node_image: ${{ matrix.version }}

    - name: Setup cluster and install CRDs
      run: |
        kind get kubeconfig --name toolhive > kconfig.yaml
        export KUBECONFIG=kconfig.yaml
        task operator-install-crds

    - name: Build and load test images
      run: |
        # Build and load vmcp image
        echo "Building vmcp image..."
        VMCP_IMAGE=$(KO_DOCKER_REPO=kind.local ko build --local -B ./cmd/vmcp | tail -n 1)
        echo "Loading vmcp image ${VMCP_IMAGE} into kind..."
        kind load docker-image --name toolhive ${VMCP_IMAGE}

        # Save VMCP_IMAGE for later steps
        echo "VMCP_IMAGE=${VMCP_IMAGE}" >> $GITHUB_ENV
        echo "Built and loaded vmcp image: ${VMCP_IMAGE}"

        # Pull and load all test server images in parallel to speed up CI
        echo "Pulling and loading test server images..."
        docker pull ${{ env.YARDSTICK_IMAGE }} &
        docker pull ghcr.io/stackloklabs/gofetch/server:1.0.1 &
        docker pull ghcr.io/stackloklabs/osv-mcp/server:0.0.7 &
        docker pull python:3.9-slim &
        docker pull curlimages/curl:8.17.0 &
        wait

        # Load all images into kind
        kind load docker-image --name toolhive ${{ env.YARDSTICK_IMAGE }}
        kind load docker-image --name toolhive ghcr.io/stackloklabs/gofetch/server:1.0.1
        kind load docker-image --name toolhive ghcr.io/stackloklabs/osv-mcp/server:0.0.7
        kind load docker-image --name toolhive python:3.9-slim
        kind load docker-image --name toolhive curlimages/curl:8.17.0

    - name: Deploy operator with VMCP_IMAGE and webhooks
      run: |
        export KUBECONFIG=kconfig.yaml
        echo "Deploying operator with vmcp image: ${{ env.VMCP_IMAGE }}"

        # Build operator and proxyrunner images
        OPERATOR_IMAGE=$(KO_DOCKER_REPO=kind.local ko build --local -B ./cmd/thv-operator | tail -n 1)
        TOOLHIVE_IMAGE=$(KO_DOCKER_REPO=kind.local ko build --local -B ./cmd/thv-proxyrunner | tail -n 1)

        # Load operator images into kind
        kind load docker-image --name toolhive ${OPERATOR_IMAGE}
        kind load docker-image --name toolhive ${TOOLHIVE_IMAGE}

        # Deploy operator with VMCP_IMAGE and webhooks enabled
        helm upgrade --install toolhive-operator deploy/charts/operator \
          --set operator.image=${OPERATOR_IMAGE} \
          --set operator.toolhiveRunnerImage=${TOOLHIVE_IMAGE} \
          --set operator.vmcpImage=${{ env.VMCP_IMAGE }} \
          --set operator.webhook.enabled=true \
          --namespace toolhive-system \
          --create-namespace \
          --kubeconfig kconfig.yaml

        # Wait for operator to be ready
        kubectl rollout status deployment/toolhive-operator -n toolhive-system --timeout=2m --kubeconfig kconfig.yaml

        # Wait for webhook pods to be ready
        echo "Waiting for webhook service to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=toolhive-operator -n toolhive-system --timeout=2m --kubeconfig kconfig.yaml

        # Verify webhook service exists and has endpoints
        echo "Verifying webhook service..."
        kubectl get svc toolhive-operator-webhook-service -n toolhive-system --kubeconfig kconfig.yaml
        kubectl get endpoints toolhive-operator-webhook-service -n toolhive-system --kubeconfig kconfig.yaml

        # Verify ValidatingWebhookConfiguration was created
        echo "Verifying ValidatingWebhookConfiguration..."
        kubectl get validatingwebhookconfiguration toolhive-operator-validating-webhook-configuration --kubeconfig kconfig.yaml

        # Check operator logs for webhook setup
        echo "Checking operator logs for webhook initialization..."
        kubectl logs -n toolhive-system deployment/toolhive-operator --tail=20 --kubeconfig kconfig.yaml | grep -i webhook || true

        # Wait for webhook server to be fully ready by testing if it responds
        echo "Waiting for webhook server to be fully ready..."
        kubectl create namespace webhook-test --kubeconfig kconfig.yaml

        # Retry loop: attempt to create a resource and wait for webhook to respond (not connection refused)
        MAX_ATTEMPTS=30
        ATTEMPT=1
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Testing webhook readiness..."

          set +e
          kubectl apply -f - --kubeconfig kconfig.yaml 2>&1 | tee /tmp/webhook-test.log <<EOF
        apiVersion: toolhive.stacklok.dev/v1alpha1
        kind: VirtualMCPServer
        metadata:
          name: test-invalid-$ATTEMPT
          namespace: webhook-test
        spec:
          incomingAuth:
            type: anonymous
        EOF
          EXIT_CODE=$?
          set -e

          # Check if we got a webhook response (not connection refused)
          if ! grep -q "connect: connection refused" /tmp/webhook-test.log; then
            echo "✓ Webhook is responding!"
            break
          fi

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "✗ Webhook failed to become ready after $MAX_ATTEMPTS attempts"
            cat /tmp/webhook-test.log
            exit 1
          fi

          echo "Webhook not ready yet (connection refused), waiting 2 seconds..."
          sleep 2
          ATTEMPT=$((ATTEMPT + 1))
        done

        # Verify webhook is actually validating (rejecting invalid resources)
        # This test passes CRD schema validation but fails webhook validation
        # by providing required CRD fields (incomingAuth) but omitting groupRef
        # which is validated by the webhook, not the CRD schema
        echo "Verifying webhook validation is working..."
        set +e
        kubectl apply -f - --kubeconfig kconfig.yaml 2>&1 | tee /tmp/webhook-validation-test.log <<EOF
        apiVersion: toolhive.stacklok.dev/v1alpha1
        kind: VirtualMCPServer
        metadata:
          name: test-missing-groupref
          namespace: webhook-test
        spec:
          incomingAuth:
            type: anonymous
          config: {}
        EOF
        set -e

        if grep -q "denied the request\|groupRef is required" /tmp/webhook-validation-test.log; then
          echo "✓ Webhook validation is working correctly"
        else
          echo "⚠ WARNING: Webhook may not be validating correctly. Test output:"
          cat /tmp/webhook-validation-test.log
        fi

        kubectl delete namespace webhook-test --kubeconfig kconfig.yaml || true

    - name: Run VirtualMCP Lifecycle E2E tests
      run: |
        export KUBECONFIG=kconfig.yaml
        task thv-operator-e2e-test-run

    - name: Cleanup cluster
      if: always()
      run: |
        kind delete cluster --name toolhive
