// Code generated by MockGen. DO NOT EDIT.
// Source: manager.go
//
// Generated by this command:
//
//	mockgen -destination=mocks/mock_manager.go -package=mocks -source=manager.go Manager
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	runner "github.com/stacklok/toolhive/pkg/runner"
	workloads "github.com/stacklok/toolhive/pkg/workloads"
	gomock "go.uber.org/mock/gomock"
	errgroup "golang.org/x/sync/errgroup"
)

// MockManager is a mock of Manager interface.
type MockManager struct {
	ctrl     *gomock.Controller
	recorder *MockManagerMockRecorder
	isgomock struct{}
}

// MockManagerMockRecorder is the mock recorder for MockManager.
type MockManagerMockRecorder struct {
	mock *MockManager
}

// NewMockManager creates a new mock instance.
func NewMockManager(ctrl *gomock.Controller) *MockManager {
	mock := &MockManager{ctrl: ctrl}
	mock.recorder = &MockManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockManager) EXPECT() *MockManagerMockRecorder {
	return m.recorder
}

// DeleteWorkloads mocks base method.
func (m *MockManager) DeleteWorkloads(ctx context.Context, names []string) (*errgroup.Group, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteWorkloads", ctx, names)
	ret0, _ := ret[0].(*errgroup.Group)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWorkloads indicates an expected call of DeleteWorkloads.
func (mr *MockManagerMockRecorder) DeleteWorkloads(ctx, names any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkloads", reflect.TypeOf((*MockManager)(nil).DeleteWorkloads), ctx, names)
}

// GetLogs mocks base method.
func (m *MockManager) GetLogs(ctx context.Context, containerName string, follow bool) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogs", ctx, containerName, follow)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLogs indicates an expected call of GetLogs.
func (mr *MockManagerMockRecorder) GetLogs(ctx, containerName, follow any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogs", reflect.TypeOf((*MockManager)(nil).GetLogs), ctx, containerName, follow)
}

// GetWorkload mocks base method.
func (m *MockManager) GetWorkload(ctx context.Context, workloadName string) (workloads.Workload, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkload", ctx, workloadName)
	ret0, _ := ret[0].(workloads.Workload)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkload indicates an expected call of GetWorkload.
func (mr *MockManagerMockRecorder) GetWorkload(ctx, workloadName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkload", reflect.TypeOf((*MockManager)(nil).GetWorkload), ctx, workloadName)
}

// ListWorkloads mocks base method.
func (m *MockManager) ListWorkloads(ctx context.Context, listAll bool, labelFilters ...string) ([]workloads.Workload, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, listAll}
	for _, a := range labelFilters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkloads", varargs...)
	ret0, _ := ret[0].([]workloads.Workload)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkloads indicates an expected call of ListWorkloads.
func (mr *MockManagerMockRecorder) ListWorkloads(ctx, listAll any, labelFilters ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, listAll}, labelFilters...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkloads", reflect.TypeOf((*MockManager)(nil).ListWorkloads), varargs...)
}

// RemoveFromGroup mocks base method.
func (m *MockManager) RemoveFromGroup(ctx context.Context, workloadNames []string, groupName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveFromGroup", ctx, workloadNames, groupName)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveFromGroup indicates an expected call of RemoveFromGroup.
func (mr *MockManagerMockRecorder) RemoveFromGroup(ctx, workloadNames, groupName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveFromGroup", reflect.TypeOf((*MockManager)(nil).RemoveFromGroup), ctx, workloadNames, groupName)
}

// RestartWorkloads mocks base method.
func (m *MockManager) RestartWorkloads(ctx context.Context, names []string) (*errgroup.Group, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestartWorkloads", ctx, names)
	ret0, _ := ret[0].(*errgroup.Group)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RestartWorkloads indicates an expected call of RestartWorkloads.
func (mr *MockManagerMockRecorder) RestartWorkloads(ctx, names any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestartWorkloads", reflect.TypeOf((*MockManager)(nil).RestartWorkloads), ctx, names)
}

// RunWorkload mocks base method.
func (m *MockManager) RunWorkload(ctx context.Context, runConfig *runner.RunConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWorkload", ctx, runConfig)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWorkload indicates an expected call of RunWorkload.
func (mr *MockManagerMockRecorder) RunWorkload(ctx, runConfig any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWorkload", reflect.TypeOf((*MockManager)(nil).RunWorkload), ctx, runConfig)
}

// RunWorkloadDetached mocks base method.
func (m *MockManager) RunWorkloadDetached(ctx context.Context, runConfig *runner.RunConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunWorkloadDetached", ctx, runConfig)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWorkloadDetached indicates an expected call of RunWorkloadDetached.
func (mr *MockManagerMockRecorder) RunWorkloadDetached(ctx, runConfig any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWorkloadDetached", reflect.TypeOf((*MockManager)(nil).RunWorkloadDetached), ctx, runConfig)
}

// StopWorkloads mocks base method.
func (m *MockManager) StopWorkloads(ctx context.Context, names []string) (*errgroup.Group, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StopWorkloads", ctx, names)
	ret0, _ := ret[0].(*errgroup.Group)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StopWorkloads indicates an expected call of StopWorkloads.
func (mr *MockManagerMockRecorder) StopWorkloads(ctx, names any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopWorkloads", reflect.TypeOf((*MockManager)(nil).StopWorkloads), ctx, names)
}
