# Proposal: Complete Token Audience Validation and Resource Parameter Implementation

## Executive Summary

This proposal outlines the implementation plan to achieve full compliance with the MCP authorization specification by adding complete token audience validation and proper resource parameter handling in ToolHive's OAuth flows.

## Background

Based on the verification of ToolHive's remote MCP authentication implementation, two areas need improvement for full MCP specification compliance:

1. **Resource Parameter**: While infrastructure exists, the `resource` parameter is not consistently sent in OAuth authorization and token requests as required by RFC 8707
2. **Token Audience Validation**: Client-side validation of token audience claims is not fully implemented

These gaps create potential security vulnerabilities and non-compliance with MCP authorization requirements.

## Problem Statement

### Current State

1. **Missing Resource Parameter in OAuth Requests**
   - The MCP specification REQUIRES the `resource` parameter per RFC 8707
   - Current implementation has the infrastructure but doesn't send the parameter
   - This breaks explicit resource binding for access tokens

2. **Incomplete Token Audience Validation**
   - Server-side validation infrastructure exists
   - Client-side validation is missing
   - Tokens could potentially be misused across different services

### Security Implications

Without proper audience validation and resource binding:
- Tokens issued for one service could be accepted by another (token confusion)
- Attackers could replay tokens across different MCP servers
- The "confused deputy" problem could occur in proxy scenarios

## Proposed Solution

### Part 1: Add Resource Parameter to OAuth Flows

#### 1.1 Update OAuth Flow Configuration

```go
// pkg/auth/discovery/discovery.go

type OAuthFlowConfig struct {
    // ... existing fields ...
    
    // Add resource parameter for RFC 8707 compliance
    Resource string // The canonical URI of the MCP server
}
```

#### 1.2 Modify OAuth Request Building

```go
// pkg/auth/oauth/flow.go

func (f *Flow) buildAuthorizationURL() string {
    // ... existing code ...
    
    // Add resource parameter if configured
    if f.config.Resource != "" {
        opts = append(opts, 
            oauth2.SetAuthURLParam("resource", f.config.Resource))
    }
    
    // ... rest of the code ...
}

func (f *Flow) exchangeCodeForToken(ctx context.Context, code string) (*oauth2.Token, error) {
    opts := []oauth2.AuthCodeOption{}
    
    // Add PKCE verifier if enabled
    if f.config.UsePKCE {
        opts = append(opts, oauth2.SetAuthURLParam("code_verifier", f.codeVerifier))
    }
    
    // Add resource parameter for token request
    if f.config.Resource != "" {
        opts = append(opts, 
            oauth2.SetAuthURLParam("resource", f.config.Resource))
    }
    
    return f.oauth2Config.Exchange(ctx, code, opts...)
}
```

#### 1.3 Derive Resource from Remote URL

```go
// pkg/runner/remote_auth.go

func (h *RemoteAuthHandler) Authenticate(ctx context.Context, remoteURL string) (*oauth2.TokenSource, error) {
    // ... existing detection code ...
    
    // Derive canonical resource URI from remote URL
    resource := deriveCanonicalResourceURI(remoteURL)
    
    // Create OAuth flow config
    flowConfig := &discovery.OAuthFlowConfig{
        // ... existing fields ...
        Resource: resource, // Add the resource parameter
    }
    
    // ... rest of the code ...
}

// deriveCanonicalResourceURI creates the canonical URI per RFC 8707
func deriveCanonicalResourceURI(remoteURL string) string {
    parsedURL, err := url.Parse(remoteURL)
    if err != nil {
        return remoteURL // Fallback to original URL
    }
    
    // Remove query and fragment per RFC 8707
    parsedURL.RawQuery = ""
    parsedURL.Fragment = ""
    
    // Normalize to lowercase scheme and host
    parsedURL.Scheme = strings.ToLower(parsedURL.Scheme)
    parsedURL.Host = strings.ToLower(parsedURL.Host)
    
    // Remove trailing slash unless it's just the root
    result := parsedURL.String()
    if strings.HasSuffix(result, "/") && result != parsedURL.Scheme+"://"+parsedURL.Host+"/" {
        result = strings.TrimSuffix(result, "/")
    }
    
    return result
}
```

### Part 2: Implement Client-Side Token Audience Validation

#### 2.1 Add Token Validation Interface

```go
// pkg/auth/token_validator.go

package auth

import (
    "context"
    "fmt"
    "github.com/golang-jwt/jwt/v5"
)

// TokenValidator validates access tokens for audience and other claims
type TokenValidator struct {
    expectedAudience string
    expectedIssuer   string
}

// NewTokenValidator creates a new token validator
func NewTokenValidator(audience, issuer string) *TokenValidator {
    return &TokenValidator{
        expectedAudience: audience,
        expectedIssuer:   issuer,
    }
}

// ValidateToken validates the token's audience and issuer claims
func (v *TokenValidator) ValidateToken(tokenString string) error {
    // Parse token without verification (verification done by server)
    token, _, err := new(jwt.Parser).ParseUnverified(tokenString, jwt.MapClaims{})
    if err != nil {
        return fmt.Errorf("failed to parse token: %w", err)
    }
    
    claims, ok := token.Claims.(jwt.MapClaims)
    if !ok {
        return fmt.Errorf("invalid token claims format")
    }
    
    // Validate audience (aud claim)
    if err := v.validateAudience(claims); err != nil {
        return err
    }
    
    // Validate issuer (iss claim)
    if err := v.validateIssuer(claims); err != nil {
        return err
    }
    
    return nil
}

func (v *TokenValidator) validateAudience(claims jwt.MapClaims) error {
    // Handle both string and array audience claims
    switch aud := claims["aud"].(type) {
    case string:
        if aud != v.expectedAudience {
            return fmt.Errorf("token audience mismatch: expected %s, got %s", 
                v.expectedAudience, aud)
        }
    case []interface{}:
        found := false
        for _, a := range aud {
            if audStr, ok := a.(string); ok && audStr == v.expectedAudience {
                found = true
                break
            }
        }
        if !found {
            return fmt.Errorf("token audience %v does not include expected %s", 
                aud, v.expectedAudience)
        }
    default:
        // If no audience claim, check for azp (authorized party) as fallback
        if azp, ok := claims["azp"].(string); ok {
            if azp != v.expectedAudience {
                return fmt.Errorf("token authorized party mismatch: expected %s, got %s",
                    v.expectedAudience, azp)
            }
        } else {
            return fmt.Errorf("token missing audience claim")
        }
    }
    
    return nil
}

func (v *TokenValidator) validateIssuer(claims jwt.MapClaims) error {
    iss, ok := claims["iss"].(string)
    if !ok {
        return fmt.Errorf("token missing issuer claim")
    }
    
    if iss != v.expectedIssuer {
        return fmt.Errorf("token issuer mismatch: expected %s, got %s",
            v.expectedIssuer, iss)
    }
    
    return nil
}
```

#### 2.2 Integrate Validation into OAuth Flow

```go
// pkg/auth/oauth/flow.go

// TokenResult - update to include validation
type TokenResult struct {
    AccessToken  string
    RefreshToken string
    TokenType    string
    Expiry       time.Time
    Claims       jwt.MapClaims
    IDToken      string
    Validated    bool // Add validation status
}

// Start - update to validate tokens
func (f *Flow) Start(ctx context.Context, skipBrowser bool) (*TokenResult, error) {
    // ... existing OAuth flow code ...
    
    // After obtaining token
    token, err := f.exchangeCodeForToken(ctx, code)
    if err != nil {
        return nil, err
    }
    
    // Validate token audience if resource is configured
    if f.config.Resource != "" {
        validator := auth.NewTokenValidator(f.config.Resource, f.config.AuthURL)
        if err := validator.ValidateToken(token.AccessToken); err != nil {
            logger.Warnf("Token audience validation failed: %v", err)
            // Don't fail the flow, but mark as not validated
            result.Validated = false
        } else {
            result.Validated = true
            logger.Debug("Token audience validation successful")
        }
    }
    
    // ... rest of the code ...
}
```

### Part 3: Add Configuration and Testing

#### 3.1 Add Configuration Options

```go
// cmd/thv/app/auth_flags.go

type RemoteAuthFlags struct {
    // ... existing fields ...
    
    // Add strict validation flag
    RemoteAuthStrictValidation bool
}

func AddRemoteAuthFlags(cmd *cobra.Command, config *RemoteAuthFlags) {
    // ... existing flags ...
    
    cmd.Flags().BoolVar(&config.RemoteAuthStrictValidation, 
        "remote-auth-strict-validation", true,
        "Enforce strict token audience validation (recommended for production)")
}
```

#### 3.2 Add Comprehensive Tests

```go
// pkg/auth/token_validator_test.go

func TestTokenValidator(t *testing.T) {
    tests := []struct {
        name            string
        token           jwt.MapClaims
        expectedAudience string
        expectedIssuer  string
        shouldPass      bool
    }{
        {
            name: "valid token with string audience",
            token: jwt.MapClaims{
                "aud": "https://mcp.example.com",
                "iss": "https://auth.example.com",
            },
            expectedAudience: "https://mcp.example.com",
            expectedIssuer:   "https://auth.example.com",
            shouldPass:       true,
        },
        {
            name: "valid token with array audience",
            token: jwt.MapClaims{
                "aud": []interface{}{"https://mcp.example.com", "https://other.example.com"},
                "iss": "https://auth.example.com",
            },
            expectedAudience: "https://mcp.example.com",
            expectedIssuer:   "https://auth.example.com",
            shouldPass:       true,
        },
        {
            name: "invalid audience",
            token: jwt.MapClaims{
                "aud": "https://wrong.example.com",
                "iss": "https://auth.example.com",
            },
            expectedAudience: "https://mcp.example.com",
            expectedIssuer:   "https://auth.example.com",
            shouldPass:       false,
        },
        {
            name: "missing audience with azp fallback",
            token: jwt.MapClaims{
                "azp": "https://mcp.example.com",
                "iss": "https://auth.example.com",
            },
            expectedAudience: "https://mcp.example.com",
            expectedIssuer:   "https://auth.example.com",
            shouldPass:       true,
        },
        {
            name: "invalid issuer",
            token: jwt.MapClaims{
                "aud": "https://mcp.example.com",
                "iss": "https://wrong-auth.example.com",
            },
            expectedAudience: "https://mcp.example.com",
            expectedIssuer:   "https://auth.example.com",
            shouldPass:       false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Create token string from claims
            token := jwt.NewWithClaims(jwt.SigningMethodHS256, tt.token)
            tokenString, _ := token.SignedString([]byte("test-secret"))
            
            // Create validator
            validator := NewTokenValidator(tt.expectedAudience, tt.expectedIssuer)
            
            // Validate
            err := validator.ValidateToken(tokenString)
            
            if tt.shouldPass {
                assert.NoError(t, err)
            } else {
                assert.Error(t, err)
            }
        })
    }
}
```

## Implementation Approach

The implementation should be done as a single cohesive change to ensure consistency and avoid partial states. All components should be implemented and tested together before merging.

### Implementation Steps

1. **Add Resource Parameter Support**
   - Update OAuth configuration structures
   - Implement canonical URI derivation
   - Add resource parameter to authorization and token requests

2. **Implement Token Validation**
   - Create TokenValidator with audience and issuer validation
   - Integrate validation into OAuth flow
   - Add configuration flag for strict validation

3. **Testing and Documentation**
   - Add comprehensive unit tests
   - Update integration tests
   - Update documentation to reflect new capabilities

## Backwards Compatibility

### Compatibility Measures

1. **Feature Flags**: Use `--remote-auth-strict-validation` flag to control enforcement
2. **Graceful Degradation**: Log warnings but don't fail if validation fails initially
3. **Default Behavior**: Enable validation by default for new installations

### Migration Path

1. **Existing Users**: Can opt-in to strict validation via configuration
2. **New Users**: Get strict validation by default
3. **Documentation**: Provide clear migration guide for existing deployments

## Security Considerations

### Benefits

1. **Token Binding**: Ensures tokens are only used for intended resources
2. **Attack Prevention**: Prevents token confusion and replay attacks
3. **Standards Compliance**: Full compliance with MCP authorization specification

### Risks

1. **Breaking Changes**: Some authorization servers may not support resource parameter
2. **Token Format Variations**: Different providers may use different audience claim formats
3. **Performance**: Additional validation adds minimal overhead

## Testing Strategy

### Unit Tests
- Test canonical URI derivation
- Test token validation with various claim formats
- Test OAuth flow with resource parameter

### Integration Tests
- Test with real OAuth providers (Google, GitHub, Auth0)
- Test with MCP-compliant authorization servers
- Test backwards compatibility scenarios

### Security Tests
- Test token confusion scenarios
- Test replay attack prevention
- Test audience validation bypass attempts

## Success Criteria

1. **Full MCP Compliance**: Pass all MCP authorization specification requirements
2. **No Breaking Changes**: Existing deployments continue to work
3. **Security Improvement**: Demonstrable prevention of token confusion attacks
4. **Performance**: Less than 1ms overhead for token validation
5. **Test Coverage**: >90% code coverage for new components

## Conclusion

This implementation will bring ToolHive to full compliance with the MCP authorization specification while improving security through proper token audience validation. The approach ensures backwards compatibility while providing a clear path to enhanced security for all users.