# Virtual MCP Server Configuration Example
# References: docs/proposals/THV-2106-virtual-mcp-server.md

# Virtual MCP metadata
name: "engineering-vmcp"
group: "engineering-team"  # Reference to ToolHive group

# ===== INCOMING AUTHENTICATION (Client → Virtual MCP) =====
incoming_auth:
  type: oidc  # oidc | anonymous | local
  oidc:
    issuer: "https://keycloak.example.com/realms/myrealm"
    client_id: "vmcp-client"
    client_secret_env: "VMCP_CLIENT_SECRET"  # Read from environment variable
    audience: "vmcp"  # Token must have aud=vmcp
    resource: "http://localhost:4483/mcp"
    scopes: ["openid", "profile", "email"]

  # Optional: Authorization policies (Cedar)
  authz:
    type: cedar
    policies:
      - |
        permit(
          principal,
          action == Action::"tools/call",
          resource
        );

# ===== OUTGOING AUTHENTICATION (Virtual MCP → Backend APIs) =====
outgoing_auth:
  # Configuration source (CLI only supports 'inline')
  source: inline  # inline (CLI only)

  # Default behavior for backends without explicit config
  default:
    type: unauthenticated  # unauthenticated | header_injection | token_exchange
    # TODO: Uncomment when pass_through is implemented
    # type: pass_through  # Forward client token unchanged

  # Per-backend authentication configurations
  # IMPORTANT: These tokens are for backend APIs (e.g., github-api, jira-api),
  # NOT for authenticating Virtual MCP to backend MCP servers.
  # Backend MCP servers receive properly scoped tokens and use them to call upstream APIs.
  backends:
    # Example 1: API key from environment variable (recommended for secrets)
    github:
      type: header_injection
      header_injection:
        header_name: "Authorization"
        header_value_env: "GITHUB_API_TOKEN"  # Read from environment variable

    # Example 2: Static header value (for non-secret values only)
    # api-service:
    #   type: header_injection
    #   header_injection:
    #     header_name: "X-API-Version"
    #     header_value: "v1"  # Literal value

    # Example: OAuth 2.0 Token Exchange (RFC 8693) for GitHub API access
    # github:
    #   type: token_exchange
    #   token_exchange:
    #     # RFC 8693 token exchange for GitHub API access
    #     token_url: "https://keycloak.example.com/realms/myrealm/protocol/openid-connect/token"
    #     client_id: "vmcp-github-exchange"
    #     client_secret_env: "GITHUB_EXCHANGE_SECRET"
    #     audience: "github-api"  # Token audience for GitHub API
    #     scopes: ["repo", "read:org"]  # GitHub API scopes
    #     subject_token_type: "access_token"  # Optional: access_token | id_token | jwt

    # Example: Token Exchange for Jira API access
    # jira:
    #   type: token_exchange
    #   token_exchange:
    #     token_url: "https://keycloak.example.com/realms/myrealm/protocol/openid-connect/token"
    #     client_id: "vmcp-jira-exchange"
    #     client_secret_env: "JIRA_EXCHANGE_SECRET"
    #     audience: "jira-api"  # Token audience for Jira API
    #     scopes: ["read:jira-work", "write:jira-work"]

    # TODO: Uncomment when pass_through strategy is implemented
    # internal-db:
    #   type: pass_through  # Forward client token unchanged

# ===== TOKEN CACHING =====
token_cache:
  provider: memory  # memory | redis | custom
  config:
    max_entries: 1000
    ttl_offset: "5m"  # Refresh tokens 5 minutes before expiry

# ===== TOOL AGGREGATION =====
aggregation:
  # Conflict resolution strategy
  conflict_resolution: prefix  # prefix | priority | manual

  # Conflict resolution details
  conflict_resolution_config:
    # For 'prefix' strategy: prefix format
    prefix_format: "{workload}_"  # Options: {workload}, {workload}_, {workload}., custom-prefix-

    # For 'priority' strategy: explicit ordering (commented out)
    # priority_order: ["github", "jira", "slack"]

  # Tool filtering and overrides (per workload in the group)
  tools:
    - workload: "github"
      filter: ["create_pr", "merge_pr", "list_issues"]
      overrides:
        create_pr:
          name: "gh_create_pr"
          description: "Create a GitHub pull request"

    - workload: "jira"
      overrides:
        create_issue:
          name: "jira_create_issue"
          description: "Create a Jira issue"

# ===== OPERATIONAL SETTINGS =====
operational:
  timeouts:
    default: 30s
    per_workload:
      github: 45s
      jira: 30s

  # Failure handling
  failure_handling:
    # Backend unavailability
    health_check_interval: 30s
    unhealthy_threshold: 3  # Mark unhealthy after N failures

    # Partial failures
    partial_failure_mode: fail  # fail | best_effort

    # Circuit breaker
    circuit_breaker:
      enabled: true
      failure_threshold: 5
      timeout: 60s

# ===== COMPOSITE TOOLS (Phase 2 - Future Feature) =====
# Composite tools enable multi-step workflows with elicitation support
# composite_tools:
#   - name: "deploy_and_notify"
#     description: "Deploy PR with user confirmation and notification"
#     parameters:
#       pr_number: {type: "integer"}
#     timeout: "30m"
#
#     steps:
#       - id: "merge"
#         tool: "github.merge_pr"
#         arguments: {pr: "{{.params.pr_number}}"}
#         on_error:
#           action: "abort"  # abort | continue | retry
#
#       - id: "confirm_deploy"
#         type: "elicitation"
#         message: "PR {{.params.pr_number}} merged. Proceed with deployment?"
#         schema:
#           type: "object"
#           properties:
#             environment:
#               type: "string"
#               enum: ["staging", "production"]
#         depends_on: ["merge"]
#         timeout: "5m"
#         on_decline:
#           action: "skip_remaining"
#         on_cancel:
#           action: "abort"
#
#       - id: "deploy"
#         tool: "kubernetes.deploy"
#         arguments:
#           pr: "{{.params.pr_number}}"
#           environment: "{{.steps.confirm_deploy.content.environment}}"
#         depends_on: ["confirm_deploy"]
#         condition: "{{.steps.confirm_deploy.action == 'accept'}}"
