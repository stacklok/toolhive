// Code generated by MockGen. DO NOT EDIT.
// Source: aggregator.go
//
// Generated by this command:
//
//	mockgen -destination=mocks/mock_interfaces.go -package=mocks -source=aggregator.go BackendDiscoverer Aggregator ConflictResolver ToolFilter ToolOverride
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	vmcp "github.com/stacklok/toolhive/pkg/vmcp"
	aggregator "github.com/stacklok/toolhive/pkg/vmcp/aggregator"
	gomock "go.uber.org/mock/gomock"
)

// MockBackendDiscoverer is a mock of BackendDiscoverer interface.
type MockBackendDiscoverer struct {
	ctrl     *gomock.Controller
	recorder *MockBackendDiscovererMockRecorder
	isgomock struct{}
}

// MockBackendDiscovererMockRecorder is the mock recorder for MockBackendDiscoverer.
type MockBackendDiscovererMockRecorder struct {
	mock *MockBackendDiscoverer
}

// NewMockBackendDiscoverer creates a new mock instance.
func NewMockBackendDiscoverer(ctrl *gomock.Controller) *MockBackendDiscoverer {
	mock := &MockBackendDiscoverer{ctrl: ctrl}
	mock.recorder = &MockBackendDiscovererMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackendDiscoverer) EXPECT() *MockBackendDiscovererMockRecorder {
	return m.recorder
}

// Discover mocks base method.
func (m *MockBackendDiscoverer) Discover(ctx context.Context, groupRef string) ([]vmcp.Backend, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Discover", ctx, groupRef)
	ret0, _ := ret[0].([]vmcp.Backend)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Discover indicates an expected call of Discover.
func (mr *MockBackendDiscovererMockRecorder) Discover(ctx, groupRef any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Discover", reflect.TypeOf((*MockBackendDiscoverer)(nil).Discover), ctx, groupRef)
}

// MockAggregator is a mock of Aggregator interface.
type MockAggregator struct {
	ctrl     *gomock.Controller
	recorder *MockAggregatorMockRecorder
	isgomock struct{}
}

// MockAggregatorMockRecorder is the mock recorder for MockAggregator.
type MockAggregatorMockRecorder struct {
	mock *MockAggregator
}

// NewMockAggregator creates a new mock instance.
func NewMockAggregator(ctrl *gomock.Controller) *MockAggregator {
	mock := &MockAggregator{ctrl: ctrl}
	mock.recorder = &MockAggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregator) EXPECT() *MockAggregatorMockRecorder {
	return m.recorder
}

// AggregateCapabilities mocks base method.
func (m *MockAggregator) AggregateCapabilities(ctx context.Context, backends []vmcp.Backend) (*aggregator.AggregatedCapabilities, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AggregateCapabilities", ctx, backends)
	ret0, _ := ret[0].(*aggregator.AggregatedCapabilities)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AggregateCapabilities indicates an expected call of AggregateCapabilities.
func (mr *MockAggregatorMockRecorder) AggregateCapabilities(ctx, backends any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AggregateCapabilities", reflect.TypeOf((*MockAggregator)(nil).AggregateCapabilities), ctx, backends)
}

// MergeCapabilities mocks base method.
func (m *MockAggregator) MergeCapabilities(ctx context.Context, resolved *aggregator.ResolvedCapabilities) (*aggregator.AggregatedCapabilities, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MergeCapabilities", ctx, resolved)
	ret0, _ := ret[0].(*aggregator.AggregatedCapabilities)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MergeCapabilities indicates an expected call of MergeCapabilities.
func (mr *MockAggregatorMockRecorder) MergeCapabilities(ctx, resolved any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeCapabilities", reflect.TypeOf((*MockAggregator)(nil).MergeCapabilities), ctx, resolved)
}

// QueryAllCapabilities mocks base method.
func (m *MockAggregator) QueryAllCapabilities(ctx context.Context, backends []vmcp.Backend) (map[string]*aggregator.BackendCapabilities, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryAllCapabilities", ctx, backends)
	ret0, _ := ret[0].(map[string]*aggregator.BackendCapabilities)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryAllCapabilities indicates an expected call of QueryAllCapabilities.
func (mr *MockAggregatorMockRecorder) QueryAllCapabilities(ctx, backends any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryAllCapabilities", reflect.TypeOf((*MockAggregator)(nil).QueryAllCapabilities), ctx, backends)
}

// QueryCapabilities mocks base method.
func (m *MockAggregator) QueryCapabilities(ctx context.Context, backend vmcp.Backend) (*aggregator.BackendCapabilities, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryCapabilities", ctx, backend)
	ret0, _ := ret[0].(*aggregator.BackendCapabilities)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryCapabilities indicates an expected call of QueryCapabilities.
func (mr *MockAggregatorMockRecorder) QueryCapabilities(ctx, backend any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryCapabilities", reflect.TypeOf((*MockAggregator)(nil).QueryCapabilities), ctx, backend)
}

// ResolveConflicts mocks base method.
func (m *MockAggregator) ResolveConflicts(ctx context.Context, capabilities map[string]*aggregator.BackendCapabilities) (*aggregator.ResolvedCapabilities, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveConflicts", ctx, capabilities)
	ret0, _ := ret[0].(*aggregator.ResolvedCapabilities)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveConflicts indicates an expected call of ResolveConflicts.
func (mr *MockAggregatorMockRecorder) ResolveConflicts(ctx, capabilities any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveConflicts", reflect.TypeOf((*MockAggregator)(nil).ResolveConflicts), ctx, capabilities)
}

// MockConflictResolver is a mock of ConflictResolver interface.
type MockConflictResolver struct {
	ctrl     *gomock.Controller
	recorder *MockConflictResolverMockRecorder
	isgomock struct{}
}

// MockConflictResolverMockRecorder is the mock recorder for MockConflictResolver.
type MockConflictResolverMockRecorder struct {
	mock *MockConflictResolver
}

// NewMockConflictResolver creates a new mock instance.
func NewMockConflictResolver(ctrl *gomock.Controller) *MockConflictResolver {
	mock := &MockConflictResolver{ctrl: ctrl}
	mock.recorder = &MockConflictResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConflictResolver) EXPECT() *MockConflictResolverMockRecorder {
	return m.recorder
}

// ResolveToolConflicts mocks base method.
func (m *MockConflictResolver) ResolveToolConflicts(ctx context.Context, tools map[string][]vmcp.Tool) (map[string]*aggregator.ResolvedTool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveToolConflicts", ctx, tools)
	ret0, _ := ret[0].(map[string]*aggregator.ResolvedTool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveToolConflicts indicates an expected call of ResolveToolConflicts.
func (mr *MockConflictResolverMockRecorder) ResolveToolConflicts(ctx, tools any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveToolConflicts", reflect.TypeOf((*MockConflictResolver)(nil).ResolveToolConflicts), ctx, tools)
}

// MockToolFilter is a mock of ToolFilter interface.
type MockToolFilter struct {
	ctrl     *gomock.Controller
	recorder *MockToolFilterMockRecorder
	isgomock struct{}
}

// MockToolFilterMockRecorder is the mock recorder for MockToolFilter.
type MockToolFilterMockRecorder struct {
	mock *MockToolFilter
}

// NewMockToolFilter creates a new mock instance.
func NewMockToolFilter(ctrl *gomock.Controller) *MockToolFilter {
	mock := &MockToolFilter{ctrl: ctrl}
	mock.recorder = &MockToolFilterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToolFilter) EXPECT() *MockToolFilterMockRecorder {
	return m.recorder
}

// FilterTools mocks base method.
func (m *MockToolFilter) FilterTools(ctx context.Context, tools []vmcp.Tool) ([]vmcp.Tool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterTools", ctx, tools)
	ret0, _ := ret[0].([]vmcp.Tool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FilterTools indicates an expected call of FilterTools.
func (mr *MockToolFilterMockRecorder) FilterTools(ctx, tools any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterTools", reflect.TypeOf((*MockToolFilter)(nil).FilterTools), ctx, tools)
}

// MockToolOverride is a mock of ToolOverride interface.
type MockToolOverride struct {
	ctrl     *gomock.Controller
	recorder *MockToolOverrideMockRecorder
	isgomock struct{}
}

// MockToolOverrideMockRecorder is the mock recorder for MockToolOverride.
type MockToolOverrideMockRecorder struct {
	mock *MockToolOverride
}

// NewMockToolOverride creates a new mock instance.
func NewMockToolOverride(ctrl *gomock.Controller) *MockToolOverride {
	mock := &MockToolOverride{ctrl: ctrl}
	mock.recorder = &MockToolOverrideMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToolOverride) EXPECT() *MockToolOverrideMockRecorder {
	return m.recorder
}

// ApplyOverrides mocks base method.
func (m *MockToolOverride) ApplyOverrides(ctx context.Context, tools []vmcp.Tool) ([]vmcp.Tool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyOverrides", ctx, tools)
	ret0, _ := ret[0].([]vmcp.Tool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplyOverrides indicates an expected call of ApplyOverrides.
func (mr *MockToolOverrideMockRecorder) ApplyOverrides(ctx, tools any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyOverrides", reflect.TypeOf((*MockToolOverride)(nil).ApplyOverrides), ctx, tools)
}
